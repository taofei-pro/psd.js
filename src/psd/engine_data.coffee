iconv = require('iconv-lite')
index = 0
originText = ''

parseEngineData = (engineData) ->
  originText = codeToString(engineData)
  result = hashStart(originText).parse()
  result

codeToString = (engineData) ->
  String.fromCharCode.apply null, engineData

# helper fun

Match = (reg, text) ->
  reg.test text

# tyep reg

hashStart = (text) ->
  reg = /^<<$/
  {
    type: 'hashStart'
    match: Match(reg, text)
    parse: ->
      obj = {}
      while index < originText.length
        kResult = parseToken(originText.substring(index))
        kParser = kResult.parser
        key = ''
        value = ''
        if kParser.type == 'property'
          key = kParser.parse()
          vResult = parseToken(originText.substring(index))
          vParser = vResult.parser
          if vParser.type == 'multiLineArrayStart' or vParser.type == 'hashStart'
            value = vParser.parse(originText.substring(index))
          else if vParser
            value = vParser.parse()
          obj[key] = value
        else if kParser.type == 'hashEnd'
          break
      obj

  }

hashEnd = (text) ->
  reg = /^>>(\x00)*$/
  {
    type: 'hashEnd'
    match: Match(reg, text)
  }

multiLineArrayStart = (text) ->
  reg = /^\[$/
  {
    type: 'multiLineArrayStart'
    match: Match(reg, text)
    parse: ->
      dataArray = []
      while index < originText.length
        vResult = parseToken(originText.substring(index))
        vParser = vResult.parser
        value = ''
        if vParser.type == 'multiLineArrayEnd'
          break
        if vParser.type == 'multiLineArrayStart' or vParser.type == 'hashStart'
          value = vParser.parse(originText.substring(index))
        else if vParser
          value = vParser.parse()
        dataArray.push value
      dataArray

  }

multiLineArrayEnd = (text) ->
  reg = /^\]$/
  {
    type: 'multiLineArrayEnd'
    match: Match(reg, text)
  }

property = (text) ->
  reg = /^\/([a-zA-Z0-9]+)$/i
  {
    type: 'property'
    match: Match(reg, text)
    parse: ->
      text.match(reg)[1]

  }

# value reg

boolean = (text) ->
  reg = /^(true|false)$/
  {
    type: 'boolean'
    match: Match(reg, text)
    parse: ->
      if text == 'true' then true else false

  }

number = (text) ->
  reg = /^-?\d+$/
  {
    type: 'number'
    match: Match(reg, text)
    parse: ->
      Number text

  }

numberWithDecimal = (text) ->
  reg = /^(-?\d*)\.(\d+)$/
  {
    type: 'numberWithDecimal'
    match: Match(reg, text)
    parse: ->
      Number text

  }

unknownTag = (text) ->
  #单行数组似乎只有数字数组的情况
  reg = /^\([a-zA-Z0-9]*\)$/
  {
    type: 'unknownTag'
    match: Match(reg, text)
    parse: ->
      text

  }

string = (text) ->
  #the text in editor has some encoding issues
  reg = /^\((\xfe\xff([^\)]|\\\))*)\)$/
  {
    name: 'string'
    match: Match(reg, text)
    parse: ->
      txt = text.match(reg)[1]
      bf = []
      i = 0
      l = txt.length
      while i < l
        bf.push txt.charCodeAt(i)
        i++
      iconv.decode new Buffer(bf), 'utf-16'
      #it`s utf-16 with bom

  }


MATCH_TYPE = [
  hashStart
  hashEnd
  multiLineArrayStart
  multiLineArrayEnd
  property
  unknownTag
  boolean
  number
  numberWithDecimal
  string
]

parseToken = (text) ->
  divider = /[ \n\t]+/
  utf16_start = /\(\xfe\xff/
  utf16_end = /[^\\]\)/
  subIndex = 0

  getText = ->
    subText = text.substring(subIndex)
    token = ''
    start = utf16_start.exec(subText)
    if start and start.index == 0
      end = utf16_end.exec(subText)
      if end.index > 0
        lastIndex = end.index + end[0].length
        token = subText.substring(0, lastIndex)
        subIndex += lastIndex
    else
      match = divider.exec(subText)
      if match
        token = subText.substring(0, match.index)
        subIndex = subIndex + match.index + match[0].length
        if token == ''
          return getText()
      else
        token = subText.substring(subIndex)
        index += subText.length
    index += subIndex
    for currentType of MATCH_TYPE
      parser = new MATCH_TYPE[currentType](token)
      if parser.match
        return {
          parser: parser
          token: token
        }
    return

  getText()



module.exports = parseEngineData

# ---
# generated by js2coffee 2.2.0