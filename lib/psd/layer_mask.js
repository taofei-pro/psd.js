// Generated by CoffeeScript 1.11.1
(function() {
  var LAYER_INFO, Layer, LayerMask, LazyExecute, Module, Util, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Module = require('coffeescript-module').Module;

  _ = require('lodash');

  Util = require('./util');

  Layer = require('./layer');

  LazyExecute = require('./lazy_execute');

  LAYER_INFO = {
    linkedLayer: require('./layer_info/linked_layer'),
    unicodePath: require('./layer_info/unicode_path'),
    textEngineData: require('./layer_info/text_engine_data'),
    filterMask: require('./layer_info/filter_mask')
  };

  module.exports = LayerMask = (function(superClass) {
    extend(LayerMask, superClass);

    LayerMask.includes(require('./layer/info'));

    function LayerMask(file, header) {
      this.file = file;
      this.header = header;
      this.layers = [];
      this.mergedAlpha = false;
      this.globalMask = null;
      this.infoKeys = [];
      this.adjustments = {};
    }

    LayerMask.prototype.skip = function() {
      return this.file.seek(this.file.readInt(), true);
    };

    LayerMask.prototype.parse = function() {
      var maskSize;
      if (this.header.version === 1) {
        maskSize = this.file.readInt();
      } else {
        maskSize = this.file.readLongLong();
      }
      this.layerEnd = maskSize + this.file.tell();
      if (maskSize <= 0) {
        return;
      }
      this.parseLayers();
      this.parseGlobalMask();
      this.layers.reverse();
      this.parseAdditionalLayerInformation();
      return this.file.seek(this.layerEnd);
    };

    LayerMask.prototype.parseLayers = function() {
      var i, j, k, layer, layerCount, layerEnd, layerInfoSize, len, ref, ref1;
      if (this.header.version === 1) {
        layerInfoSize = Util.pad2(this.file.readInt());
      } else {
        layerInfoSize = Util.pad2(this.file.readLongLong());
      }
      layerEnd = this.file.tell() + layerInfoSize;
      if (layerInfoSize > 0) {
        layerCount = this.file.readShort();
        if (layerCount < 0) {
          layerCount = Math.abs(layerCount);
          this.mergedAlpha = true;
        }
        for (i = j = 0, ref = layerCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this.layers.push(new Layer(this.file, this.header).parse());
        }
        // ref1 = this.layers;
        // for (k = 0, len = ref1.length; k < len; k++) {
        //   layer = ref1[k];
        //   layer.parseChannelImage();
        // }
      }
      return this.file.seek(layerEnd);
    };

    LayerMask.prototype.parseGlobalMask = function() {
      var length, maskEnd;
      length = this.file.readInt();
      if (length <= 0) {
        return;
      }
      maskEnd = Util.pad2(this.file.tell() + length);
      this.globalMask = _({}).tap((function(_this) {
        return function(mask) {
          mask.overlayColorSpace = _this.file.readShort();
          mask.colorComponents = [_this.file.readShort() >> 8, _this.file.readShort() >> 8, _this.file.readShort() >> 8, _this.file.readShort() >> 8];
          mask.opacity = _this.file.readShort() / 16.0;
          return mask.kind = _this.file.readByte();
        };
      })(this));
      return this.file.seek(maskEnd);
    };

    LayerMask.prototype.parseAdditionalLayerInformation = function() {
      var i, key, keyParseable, klass, length, name, pos, results;
      results = [];
      while (this.file.tell() < this.layerEnd) {
        this.file.seek(4, true);
        key = this.file.readString(4);
        length = Util.pad2(this.file.readInt());
        pos = this.file.tell();
        if (length <= 0) {
          continue;
        }
        keyParseable = false;
        for (name in LAYER_INFO) {
          if (!hasProp.call(LAYER_INFO, name)) continue;
          klass = LAYER_INFO[name];
          if (!klass.shouldParse(key)) {
            continue;
          }
          i = new klass(this, length);
          this.adjustments[name] = new LazyExecute(i, this.file).now('skip').later('parse').get();
          if (this[name] == null) {
            (function(_this) {
              return (function(name) {
                return _this[name] = function() {
                  return _this.adjustments[name];
                };
              });
            })(this)(name);
          }
          this.infoKeys.push(key);
          keyParseable = true;
          break;
        }
        if (!keyParseable) {
          results.push(this.file.seek(length, true));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return LayerMask;

  })(Module);

}).call(this);
