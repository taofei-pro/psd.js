// Generated by CoffeeScript 1.11.1
(function() {
  var MATCH_TYPE, Match, boolean, codeToString, hashEnd, hashStart, iconv, index, multiLineArrayEnd, multiLineArrayStart, number, numberWithDecimal, originText, parseEngineData, parseToken, property, string, unknownTag;

  iconv = require('iconv-lite');

  index = 0;

  originText = '';

  parseEngineData = function(engineData) {
    var result;
    originText = codeToString(engineData);
    result = hashStart(originText).parse();
    return result;
  };

  codeToString = function(engineData) {
    return String.fromCharCode.apply(null, engineData);
  };

  Match = function(reg, text) {
    return reg.test(text);
  };

  hashStart = function(text) {
    var reg;
    reg = /^<<$/;
    return {
      type: 'hashStart',
      match: Match(reg, text),
      parse: function() {
        var kParser, kResult, key, obj, vParser, vResult, value;
        obj = {};
        while (index < originText.length) {
          kResult = parseToken(originText.substring(index));
          kParser = kResult.parser;
          key = '';
          value = '';
          if (kParser.type === 'property') {
            key = kParser.parse();
            vResult = parseToken(originText.substring(index));
            vParser = vResult.parser;
            if (vParser.type === 'multiLineArrayStart' || vParser.type === 'hashStart') {
              value = vParser.parse(originText.substring(index));
            } else if (vParser) {
              value = vParser.parse();
            }
            obj[key] = value;
          } else if (kParser.type === 'hashEnd') {
            break;
          }
        }
        return obj;
      }
    };
  };

  hashEnd = function(text) {
    var reg;
    reg = /^>>(\x00)*$/;
    return {
      type: 'hashEnd',
      match: Match(reg, text)
    };
  };

  multiLineArrayStart = function(text) {
    var reg;
    reg = /^\[$/;
    return {
      type: 'multiLineArrayStart',
      match: Match(reg, text),
      parse: function() {
        var dataArray, vParser, vResult, value;
        dataArray = [];
        while (index < originText.length) {
          vResult = parseToken(originText.substring(index));
          vParser = vResult.parser;
          value = '';
          if (vParser.type === 'multiLineArrayEnd') {
            break;
          }
          if (vParser.type === 'multiLineArrayStart' || vParser.type === 'hashStart') {
            value = vParser.parse(originText.substring(index));
          } else if (vParser) {
            value = vParser.parse();
          }
          dataArray.push(value);
        }
        return dataArray;
      }
    };
  };

  multiLineArrayEnd = function(text) {
    var reg;
    reg = /^\]$/;
    return {
      type: 'multiLineArrayEnd',
      match: Match(reg, text)
    };
  };

  property = function(text) {
    var reg;
    reg = /^\/([a-zA-Z0-9]+)$/i;
    return {
      type: 'property',
      match: Match(reg, text),
      parse: function() {
        return text.match(reg)[1];
      }
    };
  };

  boolean = function(text) {
    var reg;
    reg = /^(true|false)$/;
    return {
      type: 'boolean',
      match: Match(reg, text),
      parse: function() {
        if (text === 'true') {
          return true;
        } else {
          return false;
        }
      }
    };
  };

  number = function(text) {
    var reg;
    reg = /^-?\d+$/;
    return {
      type: 'number',
      match: Match(reg, text),
      parse: function() {
        return Number(text);
      }
    };
  };

  numberWithDecimal = function(text) {
    var reg;
    reg = /^(-?\d*)\.(\d+)$/;
    return {
      type: 'numberWithDecimal',
      match: Match(reg, text),
      parse: function() {
        return Number(text);
      }
    };
  };

  unknownTag = function(text) {
    var reg;
    reg = /^\([a-zA-Z0-9]*\)$/;
    return {
      type: 'unknownTag',
      match: Match(reg, text),
      parse: function() {
        return text;
      }
    };
  };

  string = function(text) {
    var reg;
    reg = /^\((\xfe\xff([^\)]|\\\))*)\)$/;
    return {
      name: 'string',
      match: Match(reg, text),
      parse: function() {
        var bf, i, l, txt;
        txt = text.match(reg)[1];
        bf = [];
        i = 0;
        l = txt.length;
        while (i < l) {
          bf.push(txt.charCodeAt(i));
          i++;
        }
        return iconv.decode(new Buffer(bf), 'utf-16');
      }
    };
  };

  MATCH_TYPE = [hashStart, hashEnd, multiLineArrayStart, multiLineArrayEnd, property, unknownTag, boolean, number, numberWithDecimal, string];

  parseToken = function(text) {
    var divider, getText, subIndex, utf16_end, utf16_start;
    divider = /[ \n\t]+/;
    utf16_start = /\(\xfe\xff/;
    utf16_end = /[^\\]\)/;
    subIndex = 0;
    getText = function() {
      var currentType, end, lastIndex, match, parser, start, subText, token;
      subText = text.substring(subIndex);
      token = '';
      start = utf16_start.exec(subText);
      if (start && start.index === 0) {
        end = utf16_end.exec(subText);
        if (end.index > 0) {
          lastIndex = end.index + end[0].length;
          token = subText.substring(0, lastIndex);
          subIndex += lastIndex;
        }
      } else {
        match = divider.exec(subText);
        if (match) {
          token = subText.substring(0, match.index);
          subIndex = subIndex + match.index + match[0].length;
          if (token === '') {
            return getText();
          }
        } else {
          token = subText.substring(subIndex);
          index += subText.length;
        }
      }
      index += subIndex;
      for (currentType in MATCH_TYPE) {
        parser = new MATCH_TYPE[currentType](token);
        if (parser.match) {
          return {
            parser: parser,
            token: token
          };
        }
      }
    };
    return getText();
  };

  module.exports = parseEngineData;

}).call(this);
